# Create a new db schema regardless it existence
quarkus.hibernate-orm.database.generation = drop-and-create

############################################################################
# It's better to name it as 'db-make' as 'kind' has been accepted 
# as part of the identifier of KRM (Kubernetes Resource Model), which is
# the GVK (group, version, kind). 
# The supported 'db-make's are postgresql, mysql, mongo
# For details of SBO, see 
# - https://quarkus.io/version/main/guides/deploying-to-kubernetes#service_binding
# - https://docs.openshift.com/container-platform/4.10/applications/connecting_applications_to_services/getting-started-with-service-binding.html
#
# With quarkus-service-binding, kubernetes/openshift extensions installed, 
# A ServiceBinding CR will be generated once a 'datasource' being defined (See below example)
# 
# apiVersion: binding.operators.coreos.com/v1alpha1
# kind: ServiceBinding
# metadata:
#   name: microsweeper-appservice-postgresql
# spec:
#   application:
#    group: apps
#    name: microsweeper-appservice
#    version: v1
#    kind: Deployment
#  services:
#    - group: postgres-operator.crunchydata.com
#      version: v1beta1
#      kind: PostgresCluster
#      name: postgresql
#  detectBindingResources: false
#  bindAsFiles: true
#
# Notes:
# - The db name (aka DB CR name) for an anonymous datasource is default to 'db-kind'
#   (e.g. the following is the same as quarkus.datasource.postgresql.db-kind = postgresql)
# - The details of services can be customized by quarkus.kubernetes-service-binding extension, e.g.
#   quarkus.kubernetes-service-binding.services.<db-name>.api-version | kind | name   
##############################################################################
quarkus.datasource.db-kind = postgresql

##############################################################################
# OpenTelemetry
##############################################################################
%dev.quarkus.opentelemetry.enabled=true
# HTTP will be upgraded to gRPC
%dev.quarkus.opentelemetry.tracer.exporter.otlp.endpoint=http://localhost:55680
# Issues (Fixed @2.11.2.Final): need to explicitly turn on builtin sampler 
#%dev.quarkus.opentelemetry.tracer.sampler=on

##############################################################################
# These are an opinionated configuration for aligning up OCP user or sa, 
# container-image.group <-> ocp project, and quarkus profile. 
##############################################################################
# The following property dictates the target project (OCP) or namespace (k8s)
quarkus.container-image.group = dev
# Namespace/Project dedicated to user1, run quarkus cli with -Dquarkus.profile=user1
%user1.quarkus.container-image.group = user1
# To support PipelineAsCode and allow automated deployment in a different project/namespace
# The value must match the namespace defined at
#   oc get repository/rhtevan-microsweeper-quarkus -ojsonpath='{.metadata.namespace}'
%test.quarkus.container-image.group = microsweeper

quarkus.container-image.registry=quay.io

# To enable the deployment as part of 'quarkus build' process, set '-Dquarkus.kubernetes.deploy=true'
# Disable k8s deployment by default is to facilitate checking generated KRMs at target/kubernetes/openshift.yml | kubernetes.yml
quarkus.kubernetes.deploy = false
quarkus.kubernetes-client.trust-certs = true

# Add labels and annotations to facilitate select and delete KRMs
# These apply to quarkus kubernetes/openshift extension generated KRMs only
# It will have no effect to the KRMs generated by other extensions, such as service-binding.
quarkus.openshift.annotations."demo.redhat.com/vcs-url" = https://github.com/gnunn1/microsweeper-quarkus.git
quarkus.openshift.labels."demo.redhat.com/name" = microsweeper

quarkus.openshift.route.expose = true
quarkus.openshift.deployment-kind = Deployment
quarkus.openshift.build-strategy=DOCKER
###############################################################################
